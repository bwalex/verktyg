(ns verktyg.reagent
  (:require [reagent.core :as r]
            [camel-snake-kebab.core :refer [->kebab-case-keyword]]
            [camel-snake-kebab.extras :refer [transform-keys]]
            [verktyg.validation :as v])
  (:require-macros [reagent.ratom :refer [reaction]]))

;; -- General -----------------------------------------------------------------

(defn merge-comp-props
  "Given an element `e` in hiccup form and an additional set of props
  `new-props`, merge the component's props with `new-props`.
  `:style` will be merged recursively and `:class` will be string-joined."
  [e new-props]
  (let [props (nth e 1 nil)]
    (assoc e 1 (r/merge-props props new-props))))

(defn interpose-comp [sep coll]
  "Returns a seq of the elements of `coll` separated by the component `sep`
  with an autogenerated integer key."
  (let [n (count coll)
        h (first coll)
        r (rest coll)
        seps (for [n (range 0 n)]
               (merge-comp-props sep {:key n}))]
    (cons h (interleave seps r))))

(defn cljsify-props [c]
  "Given a component `c`, return a new component with kebabified props."
  (fn [props & children]
    (let [new-props (transform-keys ->kebab-case-keyword props)]
      (into [c new-props] children))))


;; -- Event propagation sandbox -----------------------------------------------
;; see https://github.com/facebook/react/issues/11387

(defn stop-ev-prop [e] (.stopPropagation e))

(defn event-sandbox [props & children]
  (into
    [:div {:style (:style props)
           :class (:class props)
           :on-copy stop-ev-prop
           :on-cut stop-ev-prop
           :on-paste stop-ev-prop
           :on-click stop-ev-prop
           :on-context-menu stop-ev-prop
           :on-double-click stop-ev-prop
           :on-drag stop-ev-prop
           :on-drag-end stop-ev-prop
           :on-drag-enter stop-ev-prop
           :on-drag-exit stop-ev-prop
           :on-drag-leave stop-ev-prop
           :on-drag-over stop-ev-prop
           :on-drag-start stop-ev-prop
           :on-drop stop-ev-prop
           :on-mouse-down stop-ev-prop
           :on-mouse-enter stop-ev-prop
           :on-mouse-leave stop-ev-prop
           :on-mouse-move stop-ev-prop
           :on-mouse-out stop-ev-prop
           :on-mouse-over stop-ev-prop
           :on-mouse-up stop-ev-prop
           :on-select stop-ev-prop
           :on-touch-cancel stop-ev-prop
           :on-touch-end stop-ev-prop
           :on-touch-move stop-ev-prop
           :on-touch-start stop-ev-prop
           :on-scroll stop-ev-prop
           :on-wheel stop-ev-prop
           :on-key-down stop-ev-prop
           :on-key-press stop-ev-prop
           :on-key-up stop-ev-prop
           :on-focus stop-ev-prop
           :on-blur stop-ev-prop
           :on-change stop-ev-prop
           :on-input stop-ev-prop
           :on-invalid stop-ev-prop
           :on-submit stop-ev-prop}]
    children))


;; -- Forms -------------------------------------------------------------------

(defn default-accessor [ev] (-> ev .-target .-value))

(defn vec-remove
  [coll pos]
  (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))

(defn make-handlers
  "Based on the form field specs in `fs` and given an atom containing the
  form data `fa`, return a map of change handlers for each form field
  specified in `fs` using either `default-accessor` or the accessor specified
  with the `acc-fn` field in the field spec.
  The change handler updates the value (as retrieved by the accessor) in the
  form data atom."
  [fs fa]
  (reduce-kv
    (fn [hs k {:keys [acc-fn array?]
               :or {acc-fn default-accessor}}]
      (let [handler-fn (if array?
                         (fn [index]
                           (fn [& vs]
                             swap! fa assoc-in [k index] (apply acc-fn vs)))
                         (fn [& vs]
                          (swap! fa assoc k (apply acc-fn vs))))]
        (cond-> hs
          true   (assoc k handler-fn)
          array? (assoc (keyword (str "add-" (name k)))
                        (fn [v]
                          (swap! fa (fn [fields]
                                      (assoc fields k (conj (get fields k []) v))))))
          array? (assoc (keyword (str "remove-" (name k)))
                        (fn [index]
                          (swap! fa (fn [fields]
                                      (assoc fields k
                                             (vec-remove (get fields k []) index)))))))))
    {}
    fs))

(defn init-form-state
  "Based on the form field specs in `fs` and given a set of `props`, return
  the initial value of each field as a map.
  The initial value for each field is specified under the `init` key of each
  field's spec. If the `init` value is a function, the initial value for the
  field is the result of calling the function with the props passed in. For
  non-function values, the value is used directly."
  [fs props]
  (reduce-kv
    (fn [r k {:keys [init]}]
      (assoc r k (if (fn? init) (init props) init))) {} fs))

(defn make-validation-reaction
  "Given a set of field specs in `fs` and an atom containing the form data
  `fa`, return a `reagent.ratom/reaction` that runs the validators specified
  under the `vals` keys of each fields' spec and return a map of field
  errors."
  [fs fa]
  (reaction (second (v/validate-kv @fa
                                   (reduce-kv (fn [r k v] (assoc r k (get v :vals [])))
                                              {}
                                              fs)))))

(defn build-form
  [field-specs props]
  (let [initv (init-form-state field-specs props)
        fields (r/atom initv)
        handlers (make-handlers field-specs fields)
        errors (make-validation-reaction field-specs fields)
        show-errors (r/atom false)]
    {:fields-initv initv
     :fields fields
     :handlers handlers
     :errors errors
     :show-errors show-errors}))
